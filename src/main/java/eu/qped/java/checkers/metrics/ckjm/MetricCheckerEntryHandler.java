package eu.qped.java.checkers.metrics.ckjm;

import eu.qped.java.checkers.metrics.data.report.MetricCheckerEntry;
import eu.qped.java.checkers.metrics.data.report.MetricsCheckerMessage;
import eu.qped.java.checkers.metrics.data.report.MetricsCheckerMessageMulti;
import eu.qped.java.checkers.metrics.data.report.MetricsCheckerMessageSingle;
import gr.spinellis.ckjm.CkjmOutputHandler;
import gr.spinellis.ckjm.ClassMetrics;
import lombok.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static eu.qped.java.checkers.metrics.ckjm.MetricCheckerEntryHandler.Metric.*;

/**
 * Class is used to handle the output generated by the checker/ckjm.
 * The output is saved in a List of {@link MetricCheckerEntry}s.
 *
 * @author Jannik Seus
 */
@Getter
public class MetricCheckerEntryHandler implements CkjmOutputHandler {

    private final List<MetricCheckerEntry> outputMetrics;

    public MetricCheckerEntryHandler() {
        this.outputMetrics = new ArrayList<>();
    }

    @Override
    public void handleClass(String className, ClassMetrics c) {

        List<MetricsCheckerMessage> metricsForClass = new ArrayList<>();

        Map<String, Integer> metricValuesCC = getCCMapInternal(c);

        metricsForClass.add(new MetricsCheckerMessageSingle(AMC, c.getAmc()));
        metricsForClass.add(new MetricsCheckerMessageSingle(CA, c.getCa()));
        metricsForClass.add(new MetricsCheckerMessageSingle(CAM, c.getCam()));
        metricsForClass.add(new MetricsCheckerMessageSingle(CBM, c.getCbm()));
        metricsForClass.add(new MetricsCheckerMessageSingle(CBO, c.getCbo()));
        metricsForClass.add(new MetricsCheckerMessageMulti(CC, metricValuesCC));
        metricsForClass.add(new MetricsCheckerMessageSingle(CE, c.getCe()));
        metricsForClass.add(new MetricsCheckerMessageSingle(DAM, c.getDam()));
        metricsForClass.add(new MetricsCheckerMessageSingle(DIT, c.getDit()));
        metricsForClass.add(new MetricsCheckerMessageSingle(LCOM, c.getLcom()));
        metricsForClass.add(new MetricsCheckerMessageSingle(LCOM3, c.getLcom3()));
        metricsForClass.add(new MetricsCheckerMessageSingle(LOC, c.getLoc()));
        metricsForClass.add(new MetricsCheckerMessageSingle(MOA, c.getMoa()));
        metricsForClass.add(new MetricsCheckerMessageSingle(MFA, c.getMfa()));
        metricsForClass.add(new MetricsCheckerMessageSingle(IC, c.getIc()));
        metricsForClass.add(new MetricsCheckerMessageSingle(NOC, c.getNoc()));
        metricsForClass.add(new MetricsCheckerMessageSingle(NPM, c.getNpm()));
        metricsForClass.add(new MetricsCheckerMessageSingle(RFC, c.getRfc()));
        metricsForClass.add(new MetricsCheckerMessageSingle(WMC, c.getWmc()));

        this.outputMetrics.add(new MetricCheckerEntry(className, metricsForClass));
    }

    /**
     * Retrieves the internally private Map ([method name, cc value]-pair) for Cyclomatic Complexity metric.
     *
     * @param classMetrics the given classMetrics
     * @return a map containing CC-values for this class' methods
     */
    private Map<String, Integer> getCCMapInternal(ClassMetrics classMetrics) {

        List<String> methodNames = classMetrics.getMethodNames();
        Map<String, Integer> metricValuesCC = new HashMap<>();
        for (String methodName : methodNames) {
            metricValuesCC.put(methodName, classMetrics.getCC(methodName));
        }
        return metricValuesCC;
    }

    /**
     * Metrics enum representing all possible class metrics for the design checker.
     *
     * @author Jannik Seus
     */
    public enum Metric {

        AMC("Average Method Complexity", 0, Double.MAX_VALUE),
        CA("Afferent Coupling", 0, Double.MAX_VALUE),
        CAM("Cohesion Among Methods Of Class", 0, 1),
        CBM("Coupling Between Methods", 0, Double.MAX_VALUE),
        CBO("Coupling Between Object Classes", 0, Double.MAX_VALUE),
        CC("McCabe's Cyclomatic Complexity", 1, Double.MAX_VALUE),
        CE("Efferent Coupling", 0, Double.MAX_VALUE),
        DAM("Data Access Metric", 0, 1),
        DIT("Depth Of Inheritance Tree", 0, Double.MAX_VALUE),
        IC("Inheritance Coupling", 0, Double.MAX_VALUE),
        LCOM("Lack Of Cohesion In Methods", 0, Double.MAX_VALUE),
        LCOM3("Lack Of Cohesion In Methods (Henderson-Sellers)", 0, 2),
        LOC("Lines Of Code", 0, Double.MAX_VALUE),
        MFA("Measure Of Functional Abstraction", 0, 1),
        MOA("Measure Of Aggregation", 0, Double.MAX_VALUE),
        NOC("Number Of Children", 0, Double.MAX_VALUE),
        NPM("Number Of Public Methods For A Class", 0, Double.MAX_VALUE),
        RFC("Response For A Class", 0, Double.MAX_VALUE),
        WMC("Weighted Methods Per Class", 0, Double.MAX_VALUE);

        private final String description;
        private final double minimum;
        private final double maximum;

        /**
         * Main constructor.
         * as well as min and max values for a specific metric. These values cannot be exceeded.
         *
         * @param description (long) description for an abbreviation of a given metric
         * @param minimum lower value which cannot be exceeded by specific metric.
         * @param maximum upper value which cannot be exceeded by specific metric.
         */
        Metric(String description, double minimum, double maximum) {
            this.description = description;
            this.minimum = minimum;
            this.maximum = maximum;
        }

        public String getDescription() {
            return description;
        }

        public double getMinimum() {
            return minimum;
        }

        public double getMaximum() {
            return maximum;
        }
    }
}
