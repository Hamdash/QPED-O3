package eu.qped.java.checkers.design.ckjm;

import eu.qped.java.checkers.design.configuration.MetricThreshold;
import eu.qped.java.checkers.design.data.DesignCheckEntry;
import eu.qped.java.checkers.design.data.DesignCheckMessage;
import gr.spinellis.ckjm.CkjmOutputHandler;
import gr.spinellis.ckjm.ClassMetrics;
import lombok.*;

import java.util.ArrayList;
import java.util.List;

import static eu.qped.java.checkers.design.ckjm.DesignCheckEntryHandler.Metric.*;

/**
 * Class is used to handle the output generated by the checker.
 * The output is saved in a nested map {@link #outputMetrics}.
 *
 * @author Jannik Seus
 */
@Data
@AllArgsConstructor(access = AccessLevel.PUBLIC)
public class DesignCheckEntryHandler implements CkjmOutputHandler {

    @Singular
    private List<DesignCheckEntry> outputMetrics;


    public DesignCheckEntryHandler() {
        this.outputMetrics = new ArrayList<>();
    }

    @Override
    public void handleClass(String className, ClassMetrics c) {

        List<DesignCheckMessage> metricsForClass = new ArrayList<>();

        metricsForClass.add(new DesignCheckMessage(WMC, c.getWmc()));
        metricsForClass.add(new DesignCheckMessage(DIT, c.getDit()));
        metricsForClass.add(new DesignCheckMessage(NOC, c.getNoc()));
        metricsForClass.add(new DesignCheckMessage(CBO, c.getCbo()));
        metricsForClass.add(new DesignCheckMessage(RFC, c.getRfc()));
        metricsForClass.add(new DesignCheckMessage(LCOM, c.getLcom()));
        metricsForClass.add(new DesignCheckMessage(CA, c.getCa()));
        metricsForClass.add(new DesignCheckMessage(CE, c.getCe()));
        metricsForClass.add(new DesignCheckMessage(NPM, c.getNpm()));
        metricsForClass.add(new DesignCheckMessage(LCOM3, c.getLcom3()));
        metricsForClass.add(new DesignCheckMessage(LOC, c.getLoc()));
        metricsForClass.add(new DesignCheckMessage(DAM, c.getDam()));
        metricsForClass.add(new DesignCheckMessage(MOA, c.getMoa()));
        metricsForClass.add(new DesignCheckMessage(MFA, c.getMfa()));
        metricsForClass.add(new DesignCheckMessage(CAM, c.getCam()));
        metricsForClass.add(new DesignCheckMessage(IC, c.getIc()));
        metricsForClass.add(new DesignCheckMessage(CBM, c.getCbm()));
        metricsForClass.add(new DesignCheckMessage(AMC, c.getAmc()));

        outputMetrics.add(new DesignCheckEntry(className, metricsForClass));
    }

    /**
     * Metrics enum representing all possible class metrics for the design checker.
     *
     * defaultValue contains an initializing value for a specific metric (before setting the value)
     * defaultThreshold[0] contains the default minimum threshold
     * defaultThreshold[1] contains the default maximum threshold
     *
     * @author Jannik Seus
     */
    public enum Metric {

        AMC("Average Method Complexity", 0d, new MetricThreshold(0,1)),
        CAM("Cohesion Among Methods of Class", 0d, new MetricThreshold(0,1)),
        CA("Afferent coupling", 0d, new MetricThreshold(0,1)),
        CBM("Coupling Between Methods", 0d, new MetricThreshold(0,1)),
        CBO("Coupling between object classes", 0d, new MetricThreshold(0,1)),
        CC("McCabe's Cyclomatic Complexity", 1d, new MetricThreshold(0,1)),
        CE("Efferent coupling", 0d, new MetricThreshold(0,1)),
        CIS("Class Interface Size", 0d, new MetricThreshold(0,1)),
        DAM("Data Access Metric", 0d, new MetricThreshold(0,1)),
        DIT("Depth of inheritance tree", 0d, new MetricThreshold(0,1)),
        IC("Inheritance Coupling", 0d, new MetricThreshold(0,1)),
        LCOM("Lack of cohesion in methods", 0d, new MetricThreshold(0,1)),
        LCOM3("Lack of cohesion in methods Henderson-Sellers version", 0d, new MetricThreshold(0,1)),
        LOC("Lines of Code", 0d, new MetricThreshold(0,1)),
        MOA("Measure of Aggregation", 0d, new MetricThreshold(0,1)),
        MFA("Measure of Functional Abstraction", 0d, new MetricThreshold(0,1)),
        NOC("Number of Children", 0d, new MetricThreshold(0,1)),
        NPM("Number of Public Methods for a class", 0d, new MetricThreshold(0,1)),
        RFC("Response for a Class", 0d, new MetricThreshold(0,1)),
        WMC("Weighted methods per class", 0d, new MetricThreshold(0,1));

        /**
         * Represents a metric's description.
         */
        private final String description;

        /**
         * A metric's value to begin with. This is not representing a field to store the data.
         */
        private final double initialValue;

        /**
         * TODO look up thresholds in paper "Thresholds for object-oriented measures"
         * Represents default thresholds (min, max) of given metrics.
         */
        private final MetricThreshold defaultThresholds;

        Metric(String description, double initialValue, MetricThreshold defaultThresholds) {
            this.description = description;
            this.initialValue = initialValue;
            this.defaultThresholds = defaultThresholds;
        }

        public String getDescription() {
            return description;
        }

        public double getInitialValue() {
            return initialValue;
        }

        public MetricThreshold getDefaultThresholds() {
            return defaultThresholds;
        }

        public double getDefaultThresholdMin() {
            return defaultThresholds.getMinThreshold();
        }

        public double getDefaultThresholdMax() {
            return defaultThresholds.getMaxThreshold();
        }
    }

}
