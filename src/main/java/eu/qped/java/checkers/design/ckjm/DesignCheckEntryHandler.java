package eu.qped.java.checkers.design.ckjm;

import eu.qped.java.checkers.design.data.DesignCheckEntry;
import eu.qped.java.checkers.design.data.DesignCheckMessage;
import eu.qped.java.checkers.design.data.DesignCheckMessageMulti;
import eu.qped.java.checkers.design.data.DesignCheckMessageSingle;
import gr.spinellis.ckjm.CkjmOutputHandler;
import gr.spinellis.ckjm.ClassMetrics;
import lombok.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static eu.qped.java.checkers.design.ckjm.DesignCheckEntryHandler.Metric.*;

/**
 * Class is used to handle the output generated by the checker/ckjm.
 * The output is saved in a List of {@link DesignCheckEntry}s.
 *
 * @author Jannik Seus
 */
@Getter
public class DesignCheckEntryHandler implements CkjmOutputHandler {

    private final List<DesignCheckEntry> outputMetrics;

    public DesignCheckEntryHandler() {
        this.outputMetrics = new ArrayList<>();
    }

    @Override
    public void handleClass(String className, ClassMetrics c) {

        List<DesignCheckMessage> metricsForClass = new ArrayList<>();

        Map<String, Integer> metricValuesCC = getCCMapInternal(c);

        metricsForClass.add(new DesignCheckMessageSingle(AMC, c.getAmc()));
        metricsForClass.add(new DesignCheckMessageSingle(CA, c.getCa()));
        metricsForClass.add(new DesignCheckMessageSingle(CAM, c.getCam()));
        metricsForClass.add(new DesignCheckMessageSingle(CBM, c.getCbm()));
        metricsForClass.add(new DesignCheckMessageSingle(CBO, c.getCbo()));
        metricsForClass.add(new DesignCheckMessageMulti(CC, metricValuesCC));
        metricsForClass.add(new DesignCheckMessageSingle(CE, c.getCe()));
        metricsForClass.add(new DesignCheckMessageSingle(DAM, c.getDam()));
        metricsForClass.add(new DesignCheckMessageSingle(DIT, c.getDit()));
        metricsForClass.add(new DesignCheckMessageSingle(LCOM, c.getLcom()));
        metricsForClass.add(new DesignCheckMessageSingle(LCOM3, c.getLcom3()));
        metricsForClass.add(new DesignCheckMessageSingle(LOC, c.getLoc()));
        metricsForClass.add(new DesignCheckMessageSingle(MOA, c.getMoa()));
        metricsForClass.add(new DesignCheckMessageSingle(MFA, c.getMfa()));
        metricsForClass.add(new DesignCheckMessageSingle(IC, c.getIc()));
        metricsForClass.add(new DesignCheckMessageSingle(NOC, c.getNoc()));
        metricsForClass.add(new DesignCheckMessageSingle(NPM, c.getNpm()));
        metricsForClass.add(new DesignCheckMessageSingle(RFC, c.getRfc()));
        metricsForClass.add(new DesignCheckMessageSingle(WMC, c.getWmc()));

        this.outputMetrics.add(new DesignCheckEntry(className, metricsForClass));
    }

    /**
     * Retrieves the internally private Map ([method name, cc value]-pair) for Cyclomatic Complexity metric.
     *
     * @param classMetrics the given classMetrics
     * @return a map containing CC-values for this class' methods
     */
    private Map<String, Integer> getCCMapInternal(ClassMetrics classMetrics) {

        List<String> methodNames = classMetrics.getMethodNames();
        Map<String, Integer> metricValuesCC = new HashMap<>();
        for (String methodName : methodNames) {
            metricValuesCC.put(methodName, classMetrics.getCC(methodName));
        }
        return metricValuesCC;
    }

    /**
     * Metrics enum representing all possible class metrics for the design checker.
     *
     * @author Jannik Seus
     */
    public enum Metric {

        AMC("Average Method Complexity", 0, Double.MAX_VALUE),
        CA("Afferent Coupling", 0, Double.MAX_VALUE),
        CAM("Cohesion Among Methods Of Class", 0, 1),
        CBM("Coupling Between Methods", 0, Double.MAX_VALUE),
        CBO("Coupling Between Object Classes", 0, Double.MAX_VALUE),
        CC("McCabe's Cyclomatic Complexity", 1, Double.MAX_VALUE),
        CE("Efferent Coupling", 0, Double.MAX_VALUE),
        DAM("Data Access Metric", 0, 1),
        DIT("Depth Of Inheritance Tree", 0, Double.MAX_VALUE),
        IC("Inheritance Coupling", 0, Double.MAX_VALUE),
        LCOM("Lack Of Cohesion In Methods", 0, Double.MAX_VALUE),
        LCOM3("Lack Of Cohesion In Methods (Henderson-Sellers)", 0, 2),
        LOC("Lines Of Code", 0, Double.MAX_VALUE),
        MFA("Measure Of Functional Abstraction", 0, 1),
        MOA("Measure Of Aggregation", 0, Double.MAX_VALUE),
        NOC("Number Of Children", 0, Double.MAX_VALUE),
        NPM("Number Of Public Methods For A Class", 0, Double.MAX_VALUE),
        RFC("Response For A Class", 0, Double.MAX_VALUE),
        WMC("Weighted Methods Per Class", 0, Double.MAX_VALUE);

        private final String description;
        private final double minimum;
        private final double maximum;

        /**
         * Main constructor.
         * as well as min and max values for a specific metric. These values cannot be exceeded.
         *
         * @param description (long) description for an abbreviation of a given metric
         * @param minimum lower value which cannot be exceeded by specific metric.
         * @param maximum upper value which cannot be exceeded by specific metric.
         */
        Metric(String description, double minimum, double maximum) {
            this.description = description;
            this.minimum = minimum;
            this.maximum = maximum;
        }

        public String getDescription() {
            return description;
        }

        public double getMinimum() {
            return minimum;
        }

        public double getMaximum() {
            return maximum;
        }
    }
}
