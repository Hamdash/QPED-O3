package eu.qped.java.checkers.design.ckjm;

import eu.qped.java.checkers.design.configuration.MetricThreshold;
import eu.qped.java.checkers.design.data.DesignCheckEntry;
import eu.qped.java.checkers.design.data.DesignCheckMessage;
import eu.qped.java.checkers.design.data.DesignCheckMessageMulti;
import eu.qped.java.checkers.design.data.DesignCheckMessageSingle;
import gr.spinellis.ckjm.CkjmOutputHandler;
import gr.spinellis.ckjm.ClassMetrics;
import lombok.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static eu.qped.java.checkers.design.ckjm.DesignCheckEntryHandler.Metric.*;

/**
 * Class is used to handle the output generated by the checker.
 * The output is saved in a List of {@link DesignCheckEntry}s.
 *
 * @author Jannik Seus
 */
@Data
@AllArgsConstructor(access = AccessLevel.PUBLIC)
public class DesignCheckEntryHandler implements CkjmOutputHandler {

    @Singular
    private List<DesignCheckEntry> outputMetrics;

    public DesignCheckEntryHandler() {
        this.outputMetrics = new ArrayList<>();
    }

    @Override
    public void handleClass(String className, ClassMetrics c) {

        List<DesignCheckMessage> metricsForClass = new ArrayList<>();

        Map<String, Integer> metricValuesCC = getCCMapInternal(c);

        metricsForClass.add(new DesignCheckMessageSingle(AMC, c.getAmc()));
        metricsForClass.add(new DesignCheckMessageSingle(CA, c.getCa()));
        metricsForClass.add(new DesignCheckMessageSingle(CAM, c.getCam()));
        metricsForClass.add(new DesignCheckMessageSingle(CBM, c.getCbm()));
        metricsForClass.add(new DesignCheckMessageSingle(CBO, c.getCbo()));
        metricsForClass.add(new DesignCheckMessageMulti(CC, metricValuesCC));
        metricsForClass.add(new DesignCheckMessageSingle(CE, c.getCe()));
        metricsForClass.add(new DesignCheckMessageSingle(DAM, c.getDam()));
        metricsForClass.add(new DesignCheckMessageSingle(DIT, c.getDit()));
        metricsForClass.add(new DesignCheckMessageSingle(LCOM, c.getLcom()));
        metricsForClass.add(new DesignCheckMessageSingle(LCOM3, c.getLcom3()));
        metricsForClass.add(new DesignCheckMessageSingle(LOC, c.getLoc()));
        metricsForClass.add(new DesignCheckMessageSingle(MOA, c.getMoa()));
        metricsForClass.add(new DesignCheckMessageSingle(MFA, c.getMfa()));
        metricsForClass.add(new DesignCheckMessageSingle(IC, c.getIc()));
        metricsForClass.add(new DesignCheckMessageSingle(NOC, c.getNoc()));
        metricsForClass.add(new DesignCheckMessageSingle(NPM, c.getNpm()));
        metricsForClass.add(new DesignCheckMessageSingle(RFC, c.getRfc()));
        metricsForClass.add(new DesignCheckMessageSingle(WMC, c.getWmc()));

        outputMetrics.add(new DesignCheckEntry(className, metricsForClass));
    }

    private Map<String,Integer> getCCMapInternal(ClassMetrics c) {

        List<String> methodNames  = c.getMethodNames();
        Map<String, Integer> metricValuesCC = new HashMap<>();
        for (String methodName : methodNames) {
            metricValuesCC.put(methodName, c.getCC(methodName));
        }
        return metricValuesCC;
    }

    /**
     * Metrics enum representing all possible class metrics for the design checker.
     *
     * defaultValue contains an initializing value for a specific metric (before setting the value)
     * defaultThreshold[0] contains the default minimum threshold
     * defaultThreshold[1] contains the default maximum threshold
     *
     * @author Jannik Seus
     */
    public enum Metric {

        AMC("Average Method Complexity", 0d, new MetricThreshold(0,1)),
        CA("Afferent coupling", 0d, new MetricThreshold(0,1)),
        CAM("Cohesion Among Methods of Class", 0d, new MetricThreshold(0,1)),
        CBM("Coupling Between Methods", 0d, new MetricThreshold(0,1)),
        CBO("Coupling between object classes", 0d, new MetricThreshold(0,1)),
        CC("McCabe's Cyclomatic Complexity", 1d, new MetricThreshold(0,1)),
        CE("Efferent coupling", 0d, new MetricThreshold(0,1)),
        DAM("Data Access Metric", 0d, new MetricThreshold(0,1)),
        DIT("Depth of inheritance tree", 0d, new MetricThreshold(0,1)),
        IC("Inheritance Coupling", 0d, new MetricThreshold(0,1)),
        LCOM("Lack of cohesion in methods", 0d, new MetricThreshold(0,1)),
        LCOM3("Lack of cohesion in methods Henderson-Sellers version", 0d, new MetricThreshold(0,1)),
        LOC("Lines of Code", 0d, new MetricThreshold(0,1)),
        MFA("Measure of Functional Abstraction", 0d, new MetricThreshold(0,1)),
        MOA("Measure of Aggregation", 0d, new MetricThreshold(0,1)),
        NOC("Number of Children", 0d, new MetricThreshold(0,1)),
        NPM("Number of Public Methods for a class", 0d, new MetricThreshold(0,1)),
        RFC("Response for a Class", 0d, new MetricThreshold(0,1)),
        WMC("Weighted methods per class", 0d, new MetricThreshold(0,1));

        /**
         * Represents the description of a metric.
         */
        private final String description;

        /**
         * A value of a metric to begin with. This is not representing a field to store the data.
         */
        private final double initialValue;

        /**
         * TODO look up thresholds in paper "Thresholds for object-oriented measures"
         * Represents default thresholds (min, max) of given metrics.
         */
        private final MetricThreshold defaultThresholds;

        Metric(String description, double initialValue, MetricThreshold defaultThresholds) {
            this.description = description;
            this.initialValue = initialValue;
            this.defaultThresholds = defaultThresholds;
        }

        public String getDescription() {
            return description;
        }

        public double getInitialValue() {
            return initialValue;
        }

        public MetricThreshold getDefaultThresholds() {
            return defaultThresholds;
        }

        public double getDefaultLowerBound() {
            return defaultThresholds.getLowerBound();
        }

        public double getDefaultUpperBound() {
            return defaultThresholds.getUpperBound();
        }
    }
}
