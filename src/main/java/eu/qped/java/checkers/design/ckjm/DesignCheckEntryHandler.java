package eu.qped.java.checkers.design.ckjm;

import eu.qped.java.checkers.design.configuration.MetricThreshold;
import eu.qped.java.checkers.design.data.DesignCheckEntry;
import eu.qped.java.checkers.design.data.DesignCheckMessage;
import eu.qped.java.checkers.design.data.DesignCheckMessageMulti;
import eu.qped.java.checkers.design.data.DesignCheckMessageSingle;
import gr.spinellis.ckjm.CkjmOutputHandler;
import gr.spinellis.ckjm.ClassMetrics;
import lombok.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static eu.qped.java.checkers.design.ckjm.DesignCheckEntryHandler.Metric.*;

/**
 * Class is used to handle the output generated by the checker.
 * The output is saved in a List of {@link DesignCheckEntry}s.
 *
 * @author Jannik Seus
 */
@Data
@AllArgsConstructor(access = AccessLevel.PUBLIC)
public class DesignCheckEntryHandler implements CkjmOutputHandler {

    @Singular
    private List<DesignCheckEntry> outputMetrics;

    public DesignCheckEntryHandler() {
        this.outputMetrics = new ArrayList<>();
    }

    @Override
    public void handleClass(String className, ClassMetrics c) {

        List<DesignCheckMessage> metricsForClass = new ArrayList<>();

        Map<String, Integer> metricValuesCC = getCCMapInternal(c);

        metricsForClass.add(new DesignCheckMessageSingle(AMC, c.getAmc()));
        metricsForClass.add(new DesignCheckMessageSingle(CA, c.getCa()));
        metricsForClass.add(new DesignCheckMessageSingle(CAM, c.getCam()));
        metricsForClass.add(new DesignCheckMessageSingle(CBM, c.getCbm()));
        metricsForClass.add(new DesignCheckMessageSingle(CBO, c.getCbo()));
        metricsForClass.add(new DesignCheckMessageMulti(CC, metricValuesCC));
        metricsForClass.add(new DesignCheckMessageSingle(CE, c.getCe()));
        metricsForClass.add(new DesignCheckMessageSingle(DAM, c.getDam()));
        metricsForClass.add(new DesignCheckMessageSingle(DIT, c.getDit()));
        metricsForClass.add(new DesignCheckMessageSingle(LCOM, c.getLcom()));
        metricsForClass.add(new DesignCheckMessageSingle(LCOM3, c.getLcom3()));
        metricsForClass.add(new DesignCheckMessageSingle(LOC, c.getLoc()));
        metricsForClass.add(new DesignCheckMessageSingle(MOA, c.getMoa()));
        metricsForClass.add(new DesignCheckMessageSingle(MFA, c.getMfa()));
        metricsForClass.add(new DesignCheckMessageSingle(IC, c.getIc()));
        metricsForClass.add(new DesignCheckMessageSingle(NOC, c.getNoc()));
        metricsForClass.add(new DesignCheckMessageSingle(NPM, c.getNpm()));
        metricsForClass.add(new DesignCheckMessageSingle(RFC, c.getRfc()));
        metricsForClass.add(new DesignCheckMessageSingle(WMC, c.getWmc()));

        outputMetrics.add(new DesignCheckEntry(className, metricsForClass));
    }

    private Map<String, Integer> getCCMapInternal(ClassMetrics c) {

        List<String> methodNames = c.getMethodNames();
        Map<String, Integer> metricValuesCC = new HashMap<>();
        for (String methodName : methodNames) {
            metricValuesCC.put(methodName, c.getCC(methodName));
        }
        return metricValuesCC;
    }

    /**
     * Metrics enum representing all possible class metrics for the design checker.
     * <p>
     * initialValue contains an initializing value for a specific metric (before setting the value)
     * defaultThreshold[0] contains the default minimum threshold
     * defaultThreshold[1] contains the default maximum threshold
     *
     * @author Jannik Seus
     */
    public enum Metric {

        AMC("Average Method Complexity", 0, Double.MAX_VALUE),
        CA("Afferent coupling", 0, Double.MAX_VALUE),
        CAM("Cohesion Among Methods of Class", 0, 1),
        CBM("Coupling Between Methods", 0, Double.MAX_VALUE),
        CBO("Coupling between object classes", 0, Double.MAX_VALUE),
        CC("McCabe's Cyclomatic Complexity", 1, Double.MAX_VALUE),
        CE("Efferent coupling", 0, Double.MAX_VALUE),
        DAM("Data Access Metric", 0, 1),
        DIT("Depth of inheritance tree", 0, Double.MAX_VALUE),
        IC("Inheritance Coupling", 0, Double.MAX_VALUE),
        LCOM("Lack of cohesion in methods", 0, Double.MAX_VALUE),
        LCOM3("Lack of cohesion in methods Henderson-Sellers version", 0, 2),
        LOC("Lines of Code", 0, Double.MAX_VALUE),
        MFA("Measure of Functional Abstraction", 0, 1),
        MOA("Measure of Aggregation", 0, Double.MAX_VALUE),
        NOC("Number of Children", 0, Double.MAX_VALUE),
        NPM("Number of Public Methods for a class", 0, Double.MAX_VALUE),
        RFC("Response for a Class", 0, Double.MAX_VALUE),
        WMC("Weighted methods per class", 0, Double.MAX_VALUE);

        /**
         * Represents the description of a metric.
         */
        private final String description;

        /**
         * TODO look up thresholds in paper "Thresholds for object-oriented measures"
         * Represents default thresholds (min, max) of given metrics.
         */
        private final double defaultLowerBound;
        private final double defaultUpperBound;

        Metric(String description, double defaultLowerBound, double defaultUpperBound) {
            this.description = description;
            this.defaultLowerBound = defaultLowerBound;
            this.defaultUpperBound = defaultUpperBound;
        }

        public String getDescription() {
            return description;
        }

        public double getDefaultLowerBound() {
            return defaultLowerBound;
        }

        public double getDefaultUpperBound() {
            return defaultUpperBound;
        }
    }
}
